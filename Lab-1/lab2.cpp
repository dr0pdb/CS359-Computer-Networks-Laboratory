#include<bits/stdc++.h>
using namespace std;
/*----------------------------------------------------------------------*/

class source
{
public:
	double producing_delay; int id;
	static int counter;

	source(double producing_delay) {
		this->producing_delay = producing_delay;
		this->id = ++counter;
	}
};

class event
{
public:
	/*
		event_type
		0 - (Packet generated by source).
		1 - (Packet started moving from source to switch). 
		2 - (packet reached input port of switch).
		3 - (packet reached the output port of switch).
		4 - (Packet reached the destination sink).
	*/
	int package_id, event_type, source_id;
	double timestamp;

	/*
		Events will be sorted by timestamp and then by package_id in the priority queue.
	*/
	event(double timestamp, int package_id, int event_type, int source_id) {
		this->package_id = package_id;
		this->timestamp = timestamp;
		this->event_type = event_type;
		this->source_id = source_id;
	}
};

bool cmp(event a, event other_event) { 
	if(a.timestamp != other_event.timestamp) {
		return a.timestamp > other_event.timestamp;
	}
	return (a.package_id > other_event.package_id);
}

class link
{
public:
	int id, bandwidth; double busytill;
	static int counter;

	link(int bandwidth) {
		this->bandwidth = bandwidth;
		this->id = ++counter;
		this->busytill = 0.0;
	}
};

class packet
{
public:
	int id, source_id; double generation_timestamp;
	static int counter;
	packet(int id, int source_id, double generation_timestamp) {
		this->id = id;
		this->source_id = source_id;
		this->generation_timestamp = generation_timestamp;
	}
};

class network_switch
{
public:
	double busytill;
	network_switch() {
		this->busytill = 0.0;
	}
};

int source::counter=0; int link::counter=0; int packet::counter=0;
int packet_size=2000;
priority_queue<event, vector<event>, std::function<bool(event, event)>> pq(cmp); // priority queue of events.
vector<packet> packets;

double get_packet_delay(int bandwidth) {
	return 1.0*packet_size/bandwidth;
}

tuple<double,double,double> simulate(double generation_rate) {
	source::counter=0; link::counter=0; packet::counter=0;
	packets.clear();
	while(!pq.empty()) pq.pop();
	int limit=25,done=0;
	link switch_to_sink(2000);
	vector<source> sources(3, source(1));
	vector<double> production_delays(3, generation_rate);
	vector<link> source_to_switch = {link(500), link(1200), link(1500)};
	packet::counter=3;
	vector<double> total_time(3, 0.0);
	int done_counter[3]={0};

	for (int i = 0; i < 3; ++i)
	{
		// set source id.
		sources[i].id=i;
		
		// different delays for each source.
		sources[i].producing_delay=production_delays[i];
		
		// Generating the first packet from each of the three sources.
		event starter(1.0, i+1, 0, sources[i].id);
		pq.push(starter);
	}
	network_switch net_switch;

	while(done < limit) {
		event current_event = pq.top(); pq.pop();
		switch(current_event.event_type) {
			case 0 : {
				/*
					A packet has been generated, schedule it to move to the input port of switch.
				*/
				packets.push_back(packet(current_event.package_id, current_event.source_id, current_event.timestamp));
				event source_to_switch_event(current_event.timestamp, current_event.package_id, 1, current_event.source_id);
				pq.push(source_to_switch_event);

				/* 
					Generate the next packet from the source.
				*/
				event next_generation_event(
					current_event.timestamp + sources[current_event.source_id].producing_delay, 
					++packet::counter,
					0,
					current_event.source_id);
				pq.push(next_generation_event);
				break;
			}
			case 1: {
				if(source_to_switch[current_event.source_id].busytill > current_event.timestamp) {
					/*
						Another packet is using this link, so again schedule this event with time when the link is available.
					*/
					event source_to_switch_event(source_to_switch[current_event.source_id].busytill, current_event.package_id, 1, current_event.source_id);
					pq.push(source_to_switch_event);
				} else {
					/*
						Link is available, so the packet is good to go.
						Update the busytill of the link.
					*/
					event packet_reaches_input_port_switch(
						current_event.timestamp + get_packet_delay(source_to_switch[current_event.source_id].bandwidth), 
						current_event.package_id,
					 	2,
					 	current_event.source_id
					);
					source_to_switch[current_event.source_id].busytill = current_event.timestamp + 
						get_packet_delay(source_to_switch[current_event.source_id].bandwidth);
					pq.push(packet_reaches_input_port_switch);
				}
				break;
			}
			case 2:
				if(net_switch.busytill > current_event.timestamp) {
					/*
						Another packet is being transferred between the input and the output port.
					*/
					event packet_reaches_input_port_switch(
						net_switch.busytill, 
						current_event.package_id,
					 	2,
					 	current_event.source_id
					);
					pq.push(packet_reaches_input_port_switch);
				} else {
					/*
						Transfer packet from input to output port of the switch.
					*/
					event packet_reaches_output_port_switch(
						current_event.timestamp + 0.0,
						current_event.package_id,
						3,
						current_event.source_id
					);
					pq.push(packet_reaches_output_port_switch);
					net_switch.busytill=packet_reaches_output_port_switch.timestamp;
				}
				break;
			case 3: {
				if(switch_to_sink.busytill > current_event.timestamp) {
					/*
						Another packet is using this link, so again schedule this event with time when the link is available.
					*/
					event switch_to_sink_event(switch_to_sink.busytill,
						current_event.package_id,
						3,
						current_event.source_id);
					pq.push(switch_to_sink_event);
				} else {
					/*
						Link is available, so the packet is good to go.
						Update the busytill of the link.
					*/
					event packet_reaches_sink(
						current_event.timestamp + get_packet_delay(switch_to_sink.bandwidth), 
						current_event.package_id,
					 	4,
					 	current_event.source_id
					);
					switch_to_sink.busytill = current_event.timestamp + get_packet_delay(switch_to_sink.bandwidth);
					pq.push(packet_reaches_sink);
				}
				break;
			}
			default: {
				done++;
				// cout<<"Packet id: "<<current_event.package_id
				// 	<<", Source_id: "<<current_event.source_id
				// 	<<", Start time: "<<packets[current_event.package_id-1].generation_timestamp
				// 	<<", End time: "<<current_event.timestamp<<endl;
				done_counter[current_event.source_id]++;
				total_time[current_event.source_id]+=(current_event.timestamp-packets[current_event.package_id-1].generation_timestamp);
			}
		}
	}

	// printf("The average delay for Source 1 producing %d packets is %.3f\n", done_counter[0],total_time[0]/done_counter[0]);
	// printf("The average delay for Source 2 producing %d packets is %.3f\n", done_counter[1],total_time[1]/done_counter[1]);
	// printf("The average delay for Source 3 producing %d packets is %.3f\n", done_counter[2],total_time[2]/done_counter[2]);

	return {total_time[0]/done_counter[0], total_time[1]/done_counter[1], total_time[2]/done_counter[2]};
}

int main() {
	// simulate(10);
	printf("Production Rate,A Avg Delay,B Avg Delay,C Avg Delay\n");
	for(double i = 0.2; i <= 10; i+=0.2) {
		tuple<double,double,double> data = simulate(i);
		printf("%.3f,%.3f,%.3f,%.3f\n", i, get<0>(data), get<1>(data), get<2>(data));
	}
    return 0;
}/*

*/
