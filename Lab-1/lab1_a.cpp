#include<bits/stdc++.h>
using namespace std;
const int INF = 1e9;
/*----------------------------------------------------------------------*/

class source
{
public:
	int producing_delay, id;
	static int counter;

	source(int producing_delay) {
		this->producing_delay = producing_delay;
		this->id = ++counter;
	}
};

class event
{
public:
	/*
		event_type
		0 - (Packet generated by source).
		1 - (Packet started moving from source to switch). 
		2 - (packet reached input port of switch).
		3 - (packet reached the output port of switch).
		4 - (Packet reached the destination sink).
	*/
	int package_id, timestamp, event_type;

	/*
		Events will be sorted by timestamp and then by package_id in the priority queue.
	*/
	event(int timestamp, int package_id, int event_type) {
		this->package_id = package_id;
		this->timestamp = timestamp;
		this->event_type = event_type;
	}
};

class link
{
public:
	int id, delay, bandwidth, busytill;
	static int counter;

	link(int delay, int bandwidth) {
		this->delay = delay;
		this->bandwidth = bandwidth;
		this->id = ++counter;
		this->busytill = -INF;
	}
};

class packet
{
public:
	int id, source_id, generation_timestamp;
	static int counter;
	packet(int source_id, int generation_timestamp) {
		this->id = ++counter;
		this->source_id = source_id;
		this->generation_timestamp = generation_timestamp;
	}
};

class network_switch
{
public:
	int delay, busytill;
	network_switch(int delay) {
		this->delay = delay;
		this->busytill = 0;
	}
};

int source::counter=0; int link::counter=0; int packet::counter=1;
int packet_size=1200, link_bandwidth = 10000;
priority_queue<event, vector<event>, greater<event>> pq; // priority queue of events.

int main() {
	int limit=500; // limit on the number of packets.
	link source_to_switch(5, link_bandwidth), switch_to_sink(3, link_bandwidth);
	source src(2);
	network_switch net_switch(4);
	event starter(1, 1, 0);
	pq.push(starter);

	while(packet::counter < limit) {
		event current_event = pq.top(); pq.pop();
		switch(current_event.event_type) {
			case 0 : {
				/*
					A packet has been generated, schedule it to move to the input port of switch.
				*/
				event source_to_switch_event(current_event.timestamp, current_event.package_id, 1);
				pq.push(source_to_switch_event);

				/* 
					Generate the next packet from the source.
				*/
				packet::counter++;
				event next_generation_event(current_event.timestamp + src.producing_delay, packet::counter, 0);
				pq.push(next_generation_event);
				break;
			}
			case 1: {
				if(source_to_switch.busytill > current_event.timestamp) {
					/*
						Another packet is using this link, so again schedule this event with time when the link is available.
					*/
					event source_to_switch_event(source_to_switch.busytill, current_event.package_id, 1);
					pq.push(source_to_switch_event);
				} else {
					/*
						Link is available, so the packet is good to go.
						Update the busytill of the link.
					*/
					event packet_reaches_input_port_switch(
						current_event.timestamp + source_to_switch.delay, 
						current_event.package_id,
					 	2
					);
					source_to_switch.busytill = current_event.timestamp + source_to_switch.delay;
					pq.push(packet_reaches_input_port_switch);
				}
				break;
			}
			case 2:
				if(net_switch.busytill > current_event.timestamp) {
					/*
						Another packet is being transferred between the input and the output port.
					*/
					
				}
				break;
			case 3:
				break;
			default:
				cout<<"case 4";
		}
	}

	// plot graph

    return 0;
}/*

*/
