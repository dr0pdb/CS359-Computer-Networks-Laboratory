#include<bits/stdc++.h>
using namespace std;
/*----------------------------------------------------------------------*/

class source
{
public:
	double lambda; int id;
	static int counter;

	source(double lambda) {
		this->lambda = lambda;
		this->id = ++counter;
	}
};

class event
{
public:
	/*
		event_type
		0 - (Packet generated by source).
		1 - (Packet started moving from source to switch). 
		2 - (packet reached input port of switch).
		3 - (packet reached the output port of switch).
		4 - (Packet reached the destination sink).
	*/
	int package_id, event_type;
	double timestamp;

	/*
		Events will be sorted by timestamp and then by package_id in the priority queue.
	*/
	event(double timestamp, int package_id, int event_type) {
		this->package_id = package_id;
		this->timestamp = timestamp;
		this->event_type = event_type;
	}
};

bool cmp(event a, event other_event) { 
	if(a.timestamp != other_event.timestamp) {
		return a.timestamp > other_event.timestamp;
	}
	return (a.package_id > other_event.package_id);
}

class link
{
public:
	int id, bandwidth; double busytill;
	static int counter;

	link(int bandwidth) {
		this->bandwidth = bandwidth;
		this->id = ++counter;
		this->busytill = 0.0;
	}
};

class packet
{
public:
	int id, source_id; double generation_timestamp;
	static int counter;
	packet(int source_id, double generation_timestamp) {
		this->id = ++counter;
		this->source_id = source_id;
		this->generation_timestamp = generation_timestamp;
	}
};

class network_switch
{
public:
	int busytill;
	network_switch() {
		this->busytill = 0;
	}
};

int source::counter=0; int link::counter=0; int packet::counter=1;
int packet_size=2000;
priority_queue<event, vector<event>, std::function<bool(event, event)>> pq(cmp); // priority queue of events.
vector<packet> packets;

double get_packet_delay(int bandwidth) {
	return 1.0*packet_size/bandwidth;
}

double fRand(double fMin, double fMax)
{
    double f = (double)rand() / RAND_MAX;
    return fMin + f * (fMax - fMin);
}

double get_next_time(double lambda) {
	double R = fRand(0.0, 1.0);

	return -log(R)/lambda;
}

double run_simulation(double lambda) {
	packets.clear();
	while(!pq.empty()) pq.pop();
	source::counter=0; link::counter=0; packet::counter=1;
	int limit=25,done=0;
	link source_to_switch(1000), switch_to_sink(500);
	source src(lambda);
	network_switch net_switch;
	double total_time=0.0;

	event starter(1.0, 1, 0);

	pq.push(starter);

	while(done < limit) {
		event current_event = pq.top(); pq.pop();
		switch(current_event.event_type) {
			case 0 : {
				/*
					A packet has been generated, schedule it to move to the input port of switch.
				*/
				packets.push_back(packet(0, current_event.timestamp));
				event source_to_switch_event(current_event.timestamp, current_event.package_id, 1);
				pq.push(source_to_switch_event);

				/* 
					Generate the next packet from the source.
				*/
				event next_generation_event(current_event.timestamp + get_next_time(src.lambda), packet::counter, 0);
				pq.push(next_generation_event);
				break;
			}
			case 1: {
				if(source_to_switch.busytill > current_event.timestamp) {
					/*
						Another packet is using this link, so again schedule this event with time when the link is available.
					*/
					event source_to_switch_event(source_to_switch.busytill, current_event.package_id, 1);
					pq.push(source_to_switch_event);
				} else {
					/*
						Link is available, so the packet is good to go.
						Update the busytill of the link.
					*/
					event packet_reaches_input_port_switch(
						current_event.timestamp + get_packet_delay(source_to_switch.bandwidth), 
						current_event.package_id,
					 	2
					);
					source_to_switch.busytill = current_event.timestamp + 
						get_packet_delay(source_to_switch.bandwidth);
					pq.push(packet_reaches_input_port_switch);
				}
				break;
			}
			case 2:
				if(net_switch.busytill > current_event.timestamp) {
					/*
						Another packet is being transferred between the input and the output port.
					*/
					event packet_reaches_input_port_switch(
						net_switch.busytill, 
						current_event.package_id,
					 	2
					);
					pq.push(packet_reaches_input_port_switch);
				} else {
					/*
						Transfer packet from input to output port of the switch.
					*/
					event packet_reaches_output_port_switch(
						current_event.timestamp + 0,
						current_event.package_id,
						3
					);
					pq.push(packet_reaches_output_port_switch);
					net_switch.busytill=packet_reaches_output_port_switch.timestamp;
				}
				break;
			case 3: {
				if(switch_to_sink.busytill > current_event.timestamp) {
					/*
						Another packet is using this link, so again schedule this event with time when the link is available.
					*/
					event switch_to_sink_event(switch_to_sink.busytill, current_event.package_id, 3);
					pq.push(switch_to_sink_event);
				} else {
					/*
						Link is available, so the packet is good to go.
						Update the busytill of the link.
					*/
					event packet_reaches_sink(
						current_event.timestamp + get_packet_delay(switch_to_sink.bandwidth), 
						current_event.package_id,
					 	4
					);
					switch_to_sink.busytill = current_event.timestamp + get_packet_delay(switch_to_sink.bandwidth);
					pq.push(packet_reaches_sink);
				}
				break;
			}
			default: {
				done++;
				// cout<<"Packet id: "<<current_event.package_id
				// 	<<" Start time: "<<packets[current_event.package_id-1].generation_timestamp
				// 	<<" End time: "<<current_event.timestamp<<endl;
				total_time += (current_event.timestamp - packets[current_event.package_id-1].generation_timestamp);
			}
		}
	}
	// printf("The average delay for 50 packets with production delay of %d seconds is %.3f seconds\n", sending_rate, total_time/50.0);
	return 1.0*total_time/limit;
}

int main() {
	
	printf("Lambda(a[i]),Average delay\n");
	for (double i = 0.1; i <= 10; i+=0.1)
	{
		printf("%f,%.3f\n", i, run_simulation(i));
	}

    return 0;
}/*

*/
